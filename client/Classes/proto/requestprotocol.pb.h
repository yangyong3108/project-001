// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: requestprotocol.proto

#ifndef PROTOBUF_requestprotocol_2eproto__INCLUDED
#define PROTOBUF_requestprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "commonprotocol.pb.h"
// @@protoc_insertion_point(includes)

namespace card_protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_requestprotocol_2eproto();
void protobuf_AssignDesc_requestprotocol_2eproto();
void protobuf_ShutdownFile_requestprotocol_2eproto();

class Request;

// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string package = 1;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 1;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  inline void set_allocated_package(::std::string* package);

  // optional string package_version = 2;
  inline bool has_package_version() const;
  inline void clear_package_version();
  static const int kPackageVersionFieldNumber = 2;
  inline const ::std::string& package_version() const;
  inline void set_package_version(const ::std::string& value);
  inline void set_package_version(const char* value);
  inline void set_package_version(const char* value, size_t size);
  inline ::std::string* mutable_package_version();
  inline ::std::string* release_package_version();
  inline void set_allocated_package_version(::std::string* package_version);

  // optional string function = 3;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 3;
  inline const ::std::string& function() const;
  inline void set_function(const ::std::string& value);
  inline void set_function(const char* value);
  inline void set_function(const char* value, size_t size);
  inline ::std::string* mutable_function();
  inline ::std::string* release_function();
  inline void set_allocated_function(::std::string* function);

  // optional string arg = 4;
  inline bool has_arg() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 4;
  inline const ::std::string& arg() const;
  inline void set_arg(const ::std::string& value);
  inline void set_arg(const char* value);
  inline void set_arg(const char* value, size_t size);
  inline ::std::string* mutable_arg();
  inline ::std::string* release_arg();
  inline void set_allocated_arg(::std::string* arg);

  // optional int64 domId = 5;
  inline bool has_domid() const;
  inline void clear_domid();
  static const int kDomIdFieldNumber = 5;
  inline ::google::protobuf::int64 domid() const;
  inline void set_domid(::google::protobuf::int64 value);

  // optional bool no_cache = 6;
  inline bool has_no_cache() const;
  inline void clear_no_cache();
  static const int kNoCacheFieldNumber = 6;
  inline bool no_cache() const;
  inline void set_no_cache(bool value);

  // optional .card_protobuf.DataType type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::card_protobuf::DataType type() const;
  inline void set_type(::card_protobuf::DataType value);

  // optional string charset = 8;
  inline bool has_charset() const;
  inline void clear_charset();
  static const int kCharsetFieldNumber = 8;
  inline const ::std::string& charset() const;
  inline void set_charset(const ::std::string& value);
  inline void set_charset(const char* value);
  inline void set_charset(const char* value, size_t size);
  inline ::std::string* mutable_charset();
  inline ::std::string* release_charset();
  inline void set_allocated_charset(::std::string* charset);

  // @@protoc_insertion_point(class_scope:card_protobuf.Request)
 private:
  inline void set_has_package();
  inline void clear_has_package();
  inline void set_has_package_version();
  inline void clear_has_package_version();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_arg();
  inline void clear_has_arg();
  inline void set_has_domid();
  inline void clear_has_domid();
  inline void set_has_no_cache();
  inline void clear_has_no_cache();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_charset();
  inline void clear_has_charset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* package_;
  ::std::string* package_version_;
  ::std::string* function_;
  ::std::string* arg_;
  ::google::protobuf::int64 domid_;
  bool no_cache_;
  int type_;
  ::std::string* charset_;
  friend void  protobuf_AddDesc_requestprotocol_2eproto();
  friend void protobuf_AssignDesc_requestprotocol_2eproto();
  friend void protobuf_ShutdownFile_requestprotocol_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// optional string package = 1;
inline bool Request::has_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_package() {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& Request::package() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.package)
  return *package_;
}
inline void Request::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set:card_protobuf.Request.package)
}
inline void Request::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(value);
  // @@protoc_insertion_point(field_set_char:card_protobuf.Request.package)
}
inline void Request::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:card_protobuf.Request.package)
}
inline ::std::string* Request::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:card_protobuf.Request.package)
  return package_;
}
inline ::std::string* Request::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_package(::std::string* package) {
  if (package_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_;
  }
  if (package) {
    set_has_package();
    package_ = package;
  } else {
    clear_has_package();
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:card_protobuf.Request.package)
}

// optional string package_version = 2;
inline bool Request::has_package_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_package_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_package_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_package_version() {
  if (package_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_version_->clear();
  }
  clear_has_package_version();
}
inline const ::std::string& Request::package_version() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.package_version)
  return *package_version_;
}
inline void Request::set_package_version(const ::std::string& value) {
  set_has_package_version();
  if (package_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_version_ = new ::std::string;
  }
  package_version_->assign(value);
  // @@protoc_insertion_point(field_set:card_protobuf.Request.package_version)
}
inline void Request::set_package_version(const char* value) {
  set_has_package_version();
  if (package_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_version_ = new ::std::string;
  }
  package_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:card_protobuf.Request.package_version)
}
inline void Request::set_package_version(const char* value, size_t size) {
  set_has_package_version();
  if (package_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_version_ = new ::std::string;
  }
  package_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:card_protobuf.Request.package_version)
}
inline ::std::string* Request::mutable_package_version() {
  set_has_package_version();
  if (package_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    package_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:card_protobuf.Request.package_version)
  return package_version_;
}
inline ::std::string* Request::release_package_version() {
  clear_has_package_version();
  if (package_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = package_version_;
    package_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_package_version(::std::string* package_version) {
  if (package_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete package_version_;
  }
  if (package_version) {
    set_has_package_version();
    package_version_ = package_version;
  } else {
    clear_has_package_version();
    package_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:card_protobuf.Request.package_version)
}

// optional string function = 3;
inline bool Request::has_function() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_function() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_function() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_function() {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_->clear();
  }
  clear_has_function();
}
inline const ::std::string& Request::function() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.function)
  return *function_;
}
inline void Request::set_function(const ::std::string& value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set:card_protobuf.Request.function)
}
inline void Request::set_function(const char* value) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(value);
  // @@protoc_insertion_point(field_set_char:card_protobuf.Request.function)
}
inline void Request::set_function(const char* value, size_t size) {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  function_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:card_protobuf.Request.function)
}
inline ::std::string* Request::mutable_function() {
  set_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:card_protobuf.Request.function)
  return function_;
}
inline ::std::string* Request::release_function() {
  clear_has_function();
  if (function_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_;
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_function(::std::string* function) {
  if (function_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_;
  }
  if (function) {
    set_has_function();
    function_ = function;
  } else {
    clear_has_function();
    function_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:card_protobuf.Request.function)
}

// optional string arg = 4;
inline bool Request::has_arg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_arg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_arg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_arg() {
  if (arg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg_->clear();
  }
  clear_has_arg();
}
inline const ::std::string& Request::arg() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.arg)
  return *arg_;
}
inline void Request::set_arg(const ::std::string& value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
  // @@protoc_insertion_point(field_set:card_protobuf.Request.arg)
}
inline void Request::set_arg(const char* value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
  // @@protoc_insertion_point(field_set_char:card_protobuf.Request.arg)
}
inline void Request::set_arg(const char* value, size_t size) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg_ = new ::std::string;
  }
  arg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:card_protobuf.Request.arg)
}
inline ::std::string* Request::mutable_arg() {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    arg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:card_protobuf.Request.arg)
  return arg_;
}
inline ::std::string* Request::release_arg() {
  clear_has_arg();
  if (arg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = arg_;
    arg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_arg(::std::string* arg) {
  if (arg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete arg_;
  }
  if (arg) {
    set_has_arg();
    arg_ = arg;
  } else {
    clear_has_arg();
    arg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:card_protobuf.Request.arg)
}

// optional int64 domId = 5;
inline bool Request::has_domid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_domid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_domid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_domid() {
  domid_ = GOOGLE_LONGLONG(0);
  clear_has_domid();
}
inline ::google::protobuf::int64 Request::domid() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.domId)
  return domid_;
}
inline void Request::set_domid(::google::protobuf::int64 value) {
  set_has_domid();
  domid_ = value;
  // @@protoc_insertion_point(field_set:card_protobuf.Request.domId)
}

// optional bool no_cache = 6;
inline bool Request::has_no_cache() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_no_cache() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_no_cache() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_no_cache() {
  no_cache_ = false;
  clear_has_no_cache();
}
inline bool Request::no_cache() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.no_cache)
  return no_cache_;
}
inline void Request::set_no_cache(bool value) {
  set_has_no_cache();
  no_cache_ = value;
  // @@protoc_insertion_point(field_set:card_protobuf.Request.no_cache)
}

// optional .card_protobuf.DataType type = 7;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::card_protobuf::DataType Request::type() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.type)
  return static_cast< ::card_protobuf::DataType >(type_);
}
inline void Request::set_type(::card_protobuf::DataType value) {
  assert(::card_protobuf::DataType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:card_protobuf.Request.type)
}

// optional string charset = 8;
inline bool Request::has_charset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_charset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_charset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_charset() {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_->clear();
  }
  clear_has_charset();
}
inline const ::std::string& Request::charset() const {
  // @@protoc_insertion_point(field_get:card_protobuf.Request.charset)
  return *charset_;
}
inline void Request::set_charset(const ::std::string& value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set:card_protobuf.Request.charset)
}
inline void Request::set_charset(const char* value) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(value);
  // @@protoc_insertion_point(field_set_char:card_protobuf.Request.charset)
}
inline void Request::set_charset(const char* value, size_t size) {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  charset_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:card_protobuf.Request.charset)
}
inline ::std::string* Request::mutable_charset() {
  set_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    charset_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:card_protobuf.Request.charset)
  return charset_;
}
inline ::std::string* Request::release_charset() {
  clear_has_charset();
  if (charset_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = charset_;
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_charset(::std::string* charset) {
  if (charset_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete charset_;
  }
  if (charset) {
    set_has_charset();
    charset_ = charset;
  } else {
    clear_has_charset();
    charset_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:card_protobuf.Request.charset)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace card_protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_requestprotocol_2eproto__INCLUDED
